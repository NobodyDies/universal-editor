# Внедрение директив извне

Для внедрения нового компонента нужно написать директиву с именем editorFieldNewType , где NewType – тип нового 
внедряемого компонента. В контроллере директивы обязательно должны быть выполнены
следующие условия:

* Реализован метод, который берет значение поля и сливает его в конечный объект универсального редактора, затем 
отправляет его на бекенд при редактировании сущности.

```javascript
this.getFieldValue = function() { 
    /*логика*/ 
    return valueField; 
};
```

* Реализован метод для инициализации новой сущности при создании.

```javascript
this.getInitialValue = function() { 
    /*логика*/ 
    return valueField 
};
```

* Реализовано событие инициализации сущности при редактировании. Аргумент обработчика data — сущность, поступившая с 
API. Из этого аргумента слудует извлечь значение поля и присвоить его переменной контроллера 
valueField ($scope.fieldName содержит имя поля, передаваемое У-редактором в директиву).

```javascript
$scope.$on('editor:entity_loaded', function (event, data) {
  vm.fieldValue = vm.data[$scope.fieldName];
  /*логика*/
});
```

* Должна быть выполнена инструкция, оповещающая EditEntityStorage о новом контроллере, для обращения к выше 
представленным методам:

```javascript
EditEntityStorage.addFieldController(this);
```

Для обмена выходными значениями полей между контроллерами можно использовать функцию `getValueField` сервиса 
`EditEntityStorage`. В качестве аргумента она принимает имя поля из конфигурации редактора. Данный функционал может 
быть полезен, например, при реализации кастомной валидации полей на основании значений других полей.

Например, значение поля title можно извлечь следующим образом:

```javascript
var fieldTitle = EditEntityStorage.getValueField('title');
```